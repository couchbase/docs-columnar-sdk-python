= Managing Connections
:description: This section describes how to connect the {name-sdk} to a Couchbase cluster.
:page-toclevels: 2


// Note to editors
// 
// This page pulls in content from -sdk-common-
// and code samples from -example-dir-
// 
// It can be seen built at wwww.


[abstract]
{description}
It contains best practices as well as information on TLS/SSL and advanced connection options, and a sub-page on troubleshooting Cloud connections.


Our xref:hello-world:start-using-sdk.adoc[Getting Started pages] cover the basics of making a connection to a Capella or self-managed Couchbase cluster.
This page is a wider look at the topic.


== Connecting to a Cluster

The examples below use these imports:

[source,python]
----
from couchbase_columnar.cluster import Cluster
from couchbase_columnar.credential import Credential
from couchbase_columnar.options import (ClusterOptions,
                                        SecurityOptions)
----

A connection to a Couchbase Server cluster is represented by a `Cluster` object.
A `Cluster` provides access to databases, scopes, and collections, as well as various Columnar services and management interfaces.
The simplest way to create a `Cluster` object is to call `Cluster.createnstance()` with a <<connection-strings, connection string>>, user credentials, and any optional settings:


[source,python]
----
def main() -> None:
    # Update this to your cluster
    connstr = 'couchbases://--your-instance--'
    username = 'username'
    pw = 'Password!123'
    # User Input ends here.

    cred = Credential.from_username_and_password(username, pw)
    # Configure a secure connection to a Couchbase internal pre-production cluster.
    # (Omit this when connecting to a production cluster!)
    from couchbase_columnar.common.core._certificates import _Certificates
    sec_opts = SecurityOptions.trust_only_certificates(_Certificates.get_nonprod_certificates())
    opts = ClusterOptions(security_options=sec_opts)
    cluster = Cluster.create_instance(connstr, cred, opts)
----


The client certificate for connecting to a Capella Columnar instance is included in the SDK installation.

NOTE: Capella's root certificate is *not* signed by a well known CA (Certificate Authority).
However, as the certificate is bundled with the SDK, it is trusted by default.




=== Connection Strings

A Couchbase connection string is a comma-delimited list of IP addresses and/or hostnames, optionally followed by a list of parameters.

The parameter list is just like the query component of a URI; name-value pairs have an equals sign (`=`) separating the name and value, with an ampersand (`&`) between each pair.
Just as in a URI, the first parameter is prefixed by a question mark (`?`).

For Columnar, as for all Capella products, connection must be made with Transport Layer Security (TLS) -- for full encryption of client-side traffic --
for which the `couchbases://` schema is used as the root of the connection string (note the trailing *s*).

.Simple connection string with one seed node
----
cb.<your-endpoint>.cloud.couchbase.com
----

////
In a production environment, your connection string should include the addresses of multiple server nodes in case some are currently unavailable.
Multiple addresses may be specified in a connection string by delimiting them with commas:

.Connection string with two seed nodes
----
nodeA.example.com,nodeB.example.com
----

TIP: You don't need to include the address of every node in the cluster.
The client fetches the full address list from the first node it is able to contact.
////


.Connection string with two parameters
----
cb.<your-endpoint>.cloud.couchbase.com?io.networkResolution=external&timeout.kvTimeout=10s
----

The full list of recognized parameters is documented in the xref:ref:client-settings.adoc[client settings reference].


////
Any client setting with a system property name may also be specified as a connection string parameter (without the `com.couchbase.env.` prefix).

WARNING: When creating a `Cluster` using a custom `ClusterEnvironment`, *_connection string parameters are ignored_*, since client settings are frozen when the cluster environment is built.
////


////
=== Cluster Environment

A `ClusterEnvironment` manages shared resources like thread pools, timers, and schedulers.
It also holds the client settings.
One way to customize the client's behavior is to build your own `ClusterEnvironment` with custom settings:

[source,scala]
----
include::devguide:example$scala/ManagingConnections.scala[tag=env,indent=0]
----

This is a verbose example for simplicity, and the user may prefer to use `flatMap` or a for-comprehension to combine the multiple `Try`.

Note there are `com.couchbase.client.scala.env` and `com.couchbase.client.core.env` versions of all environment parameters: be sure to import the `.scala` versions.

TIP: If you create a `Cluster` without specifying a custom environment, the client creates a default environment used exclusively by that `Cluster`.
This default `ClusterEnvironment` is managed completely by the Scala SDK, and is automatically shut down when the associated `Cluster` is disconnected.
////


////
=== Connection Lifecycle

Most of the high-level classes in the Scala SDK are designed to be safe for concurrent use by multiple threads.
You will get the best performance if you share and reuse instances of `ClusterEnvironment`, `Cluster`, `Bucket`, `Scope`, and `Collection`, all of which are thread-safe.

We recommend creating a single `Cluster` instance when your application starts up, and sharing this instance throughout your application.
If you know at startup time which buckets, scopes, and collections your application will use, we recommend obtaining them from the `Cluster` at startup time and sharing those instances throughout your application as well.

Before your application stops, gracefully shut down the client by calling the `disconnect()` method of each `Cluster` you created.
If you created any `ClusterEnvironment` instances, call their `shutdown()` method after disconnecting the associated clusters.
////



////
[#multiple-clusters]
=== Connecting to Multiple Clusters

If a single application needs to connect to multiple Couchbase Server clusters, we recommend creating a single `ClusterEnvironment` and sharing it between the `Clusters`.
We will use a for-comprehension here to avoid excessive `Try` juggling.

[source,scala]
----
include::devguide:example$scala/ManagingConnections.scala[tag=shared,indent=0]
----

Remember, whenever you manually create a `ClusterEnvironment` like this, the SDK will not shut it down when you call `Cluster.disconnect()`.
Instead you are responsible for shutting it down after disconnecting all clusters that share the environment.
////




////
=== Waiting for Bootstrap Completion

Opening resources is asynchronous.
That is, the call to `cluster.bucket` or `Cluster.connect` will complete instantly, and opening that resource will continue in the background.

You can force waiting for the resource to be opened with a call to `waitUntilReady`, which is available on both the `Cluster` and `Bucket`.
Here is an example of using it on the bucket:

[source,scala]
----
include::devguide:example$scala/ManagingConnections.scala[tag=wait-until-ready,indent=0]
----

If not present, then the first Key Value (KV) operation on the bucket will wait for it to be ready.
Any issues opening that bucket (for instance, if it does not exist), will result in an error being raised from that data operation.

Other timeout issues may occur when using the SDK located geographically separately from the Couchbase Server cluster -- 
this is xref:project-docs:compatibility.adoc#network-requirements[not recommended in production deployments], but often occurs during development.
See the <<working-in-the-cloud,Cloud section>> below for some suggestions of settings adjustments.
////


////
== Alternate Addresses and Custom Ports

If your Couchbase Server cluster is running in a containerized, port mapped, or otherwise NAT'd environment like Docker or Kubernetes, a client running outside that environment may need additional information in order to connect the cluster.
Both the client and server require special configuration in this case.

On the server side, each server node must be configured to advertise its external address as well as any custom port mapping.
This is done with the https://docs.couchbase.com/server/6.5/cli/cbcli/couchbase-cli-setting-alternate-address.html[`setting-alternate-address` CLI command] introduced in Couchbase Server 6.5.
A node configured in this way will advertise two addresses: one for connecting from the same network, and another for connecting from an external network.

On the client side, the externally visible ports must be used when connecting.
If the external ports are not the default, you can specify custom ports using the overloaded `Cluster.connect()` method that takes a set of `SeedNode` objects instead of a connection string.

[source,scala]
----
include::devguide:example$scala/ManagingConnections.scala[tag=seed-nodes,indent=0]
----

TIP: In a deployment that uses multi-dimensional scaling, a custom KV port is only applicable for nodes running the KV service.
A custom manager port may be specified regardless of which services are running on the node.

In many cases the client is able to automatically select the correct set of addresses to use when connecting to a cluster that advertises multiple addresses.
If the detection heuristic fails in your environment, you can override it by setting the `io.networkResolution` client setting to `default` if the client and server are on the same network, or `external` if they're on different networks.

NOTE: Any TLS certificates must be set up at the point where the connections are being made.
////





////
// DNS-SRV

include::{version-common}@sdk:shared:partial$dnssrv-pars.adoc[tag=dnssrv]

DNS SRV bootstrapping is enabled by default in the {name-sdk}.
In order to make the SDK use the SRV records, you need to pass in the hostname from your records (here `example.com`):

[source,scala]
----
include::devguide:example$scala/ManagingConnections.scala[tag=dnssrv,indent=0]
----

[source,scala]
----
ClusterEnvironment env = ClusterEnvironment.builder().ioConfig(IoConfig.enableDnsSrv(true)).build();
----

If the DNS SRV records could not be loaded properly you'll get the exception logged and the given host name will be used as a A record lookup.

----
WARNING: DNS SRV lookup failed, proceeding with normal bootstrap.
javax.naming.NameNotFoundException: DNS name not found [response code 3];
   remaining name '_couchbase._tcp.example.com'
	at com.sun.jndi.dns.DnsClient.checkResponseCode(DnsClient.java:651)
	at com.sun.jndi.dns.DnsClient.isMatchResponse(DnsClient.java:569)
----

Also, if you pass in more than one node, DNS SRV bootstrap will not be initiated:

----
INFO: DNS SRV enabled, but less or more than one seed node given.
Proceeding with normal bootstrap.
----
////


== Local Development


We strongly recommend that the client and server xref:project-docs:compatibility.adoc#network-requirements[are in the same LAN-like environment] (e.g. AWS Region).
As this may not always be possible during development, read the guidance on working with xref:ref:client-settings.adoc#commonly-used-options[constrained network environments].
More details on connecting your client code to Couchbase Capella can be found xref:cloud:clouds:connect-an-sdk.adoc#connecting-your-sdk-to-capella[in the Capella Operational docs].


=== Troubleshooting Connections to Cloud

Some DNS caching providers (notably, home routers) can’t handle an SRV record that’s large -- if you have DNS-SRV issues with such a set-up, reduce your DNS-SRV to only include three records.
[_For development only, not production._]. 
Our xref:troubleshooting-connections.adoc[Troubleshooting Connections] page will help you to diagnose this and other problems -- as well as introducing the SDK doctor tool.




